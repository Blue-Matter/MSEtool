
#' Reads MLE estimates from Stock Synthesis file structure into an operating model using package r4ss.
#'
#'
#' @description A function that uses the file location of a fitted SS3 model including input files to population the
#' various slots of an operating model with MLE parameter estimates. The function mainly populates the Stock and Fleet portions
#' of the operating model; the user still needs to parameterize most of the observation and implementation portions of the operating model.
#' @param SSdir A folder with Stock Synthesis input and output files in it.
#' @param nsim The number of simulations to take for parameters with uncertainty (for OM@@cpars custom parameters).
#' @param proyears The number of projection years for MSE
#' @param reps The number of stochastic replicates within each simulation in the operating model.
#' @param maxF The maximum allowable F in the operating model.
#' @param seed The random seed for the operating model.
#' @param interval The management interval. Numeric. How frequently is a management decision made?
#' @param Obs The observation model (class Obs).
#' @param Imp The implementation model (class Imp).
#' @param import_mov Logical, whether to import movement matrix from the assessment.
#' @param Name The name of the operating model
#' @param Source Reference to assessment documentation e.g. a url
#' @param Author Who did the assessment
#' @param Gen Genders to import. Numeric. `Gen=1` for first gender (usually female),
#'  `Gen=2` for second gender (usually male), etc. `Gen=1:2` (default) uses average from both genders
#' @param meanh logical. Use mean steepness (TRUE) or sample from a distribution (FALSE)?
#' @param ... Arguments to pass to \link[r4ss]{SS_output}.
#' @note Currently supports versions of r4ss on CRAN (v.1.24) and Github (v.1.34-35). Function may be incompatible with other versions of r4ss.
#' @details The function generally uses values from the terminal year of the assessment for most life history parameters (maturity, M, etc). This function
#' does detect time-varying growth in the assessment and uses annual length/weight-at-age for historical years.
#' Selectivity is derived from the F-at-age matrix.
#' @return An object of class OM.
#' @author T. Carruthers, Q. Huynh, and A. Hordyk
#' @export
SS2OM <- function(SSdir, nsim = 48, proyears = 50, reps = 1, maxF = 3,
                      seed = 1, interval=1, Obs = OMtool::Generic_Obs,
                      Imp = OMtool::Perfect_Imp,
                      import_mov = TRUE, Name = "OM generated by SS2OM function",
                      Source = "No source provided", Author = "No author provided",
                      Gen=1:2, meanh=TRUE, ...) {
  
  if(!requireNamespace("r4ss", quietly = TRUE)) {
    stop("Download the r4ss package to use this function.",
         " It is recommended to install the Github version with: ",
         "devtools::install_github(\"r4ss/r4ss\")", call. = FALSE)
  }
  if(utils::packageVersion("r4ss") < 1.34 && utils::packageVersion("r4ss") != 1.24) {
    warning(paste0("r4ss version ", utils::packageVersion("r4ss"),
                   " was detected. This function is only tested on versions 1.24 and 1.34-35."), call. = FALSE)
  }
  
  if (class(SSdir) == 'character') {
    dots <- list(dir = SSdir, ...)
    if(!any(names(dots) == "covar")) dots$covar <- FALSE
    if(!any(names(dots) == "forecast")) dots$forecast <- FALSE
    if(!any(names(dots) == "ncols")) dots$ncols <- 1e3
    if(!any(names(dots) == "printstats")) dots$printstats <- FALSE
    if(!any(names(dots) == "verbose")) dots$verbose <- FALSE
    if(!any(names(dots) == "warn")) dots$warn <- FALSE
    
    message("-- Using function SS_output of package r4ss version ",
            packageVersion("r4ss"), " to extract data from SS file structure --")
    message("Reading directory: ", SSdir)
    replist <- try(do.call(r4ss::SS_output, dots), silent = TRUE)
    if(is.character(replist))
      stop("r4ss::SS_output function returned an error -\n", replist, call. = FALSE)
    message("-- End of r4ss operations --\n")
  } else if (class(SSdir) == 'list') {
    replist <- SSdir
  } else {
    stop("SSdir must be replist or SSdir")
  }
  
  season_as_years <- FALSE
  if(replist$nseasons == 1 && replist$seasduration < 1) {
    message("Season-as-years detected in SS model. There is one season in the year with duration of ",
            replist$seasduration, "year.")
    season_as_years <- TRUE
    nseas <- 1/replist$seasduration
    message("DLMtool operating model is an annual model. Since the SS model is seasonal, we need to aggregate over seasons.\n")
  } else {
    nseas <- replist$nseasons
    if(nseas > 1) {
      message("DLMtool operating model is an annual model. Since the SS model is seasonal, we need to aggregate over seasons.\n")
    }
  }
  
  # ---- Create OM object ----
  Stock <- new("Stock")
  Fleet <- new("Fleet")
  OM <- new("OM", Stock = Stock, Fleet = Fleet, Obs = Obs, Imp = Imp)
  OM@nsim <- nsim
  OM@proyears <- proyears
  OM@Name <- Name
  OM@Source <- paste0(Source, ". Author: ", Author, ".")
  mainyrs <- replist$startyr:replist$endyr
  OM@nyears <- nyears <- ceiling(length(mainyrs) / ifelse(season_as_years, nseas, 1))
  
  seas1_yind_full <- expand.grid(nseas = 1:nseas, nyears = 1:nyears) # Convert assessment years to true years
  seas1_yind <- which(seas1_yind_full$nseas == 1) # Assessment years that correspond to first season of a true year
  
  OM@maxF <- maxF
  OM@reps <- reps
  OM@seed <- seed
  OM@CurrentYr <- ifelse(season_as_years, nyears, replist$endyr)
  
  # ---- Stock Parameters ----
  # ---- Stock-recruit relationship ----
  AgeRec <- 0 # recruit to age 0
  Genders <- replist$natage_annual_1_no_fishery$Gender %>% unique()
  ind <- which(names(replist$natage_annual_1_no_fishery) == "0")
  ind2 <- ncol(replist$natage_annual_1_no_fishery)
  N_at_age <- replist$natage_annual_1_no_fishery %>% tidyr::gather(., "Age", 'N', ind:ind2)
  
  if (!is.null(N_at_age$Sex)) {
    N_at_age <- N_at_age %>% dplyr::filter(Sex %in% Gen, Yr==min(mainyrs), Age==AgeRec) %>%
      dplyr::summarise(N=sum(N))
  } else {
    N_at_age <- N_at_age %>% dplyr::filter(Gender %in% Gen, Year==min(mainyrs), Age==AgeRec) %>%
      dplyr::summarise(N=sum(N))
  }
  
  R0 <- N_at_age$N # R0 is unfished recruits to age AgeRec
  
  SR_ind <- match(mainyrs, replist$recruit$Yr)
  SSB <- replist$recruit$SpawnBio[SR_ind]
  SSB0 <- replist$SBzero
  rec <- replist$recruit$pred_recr[SR_ind] # recruits to age 0
  
  SpR0 <- SSB0/(R0 * ifelse(season_as_years, nseas, 1))
  
  # In season as year model, R0 is the seasonal rate of recruitment, must adjust for annual model
  OM@R0 <- R0 * ifelse(season_as_years, nseas, 1)
  message("R0 found")
  
  # Steepness
  if(replist$SRRtype == 3 || replist$SRRtype == 6) { # Beverton-Holt SR
    SR <- "BH"
    OM@SRrel <- 1L
    steep <- replist$parameters[grepl("steep", rownames(replist$parameters)), ]
    hs_sd <- ifelse(is.na(steep$Parm_StDev), 0, steep$Parm_StDev)
    message("Beverton-Holt stock-recruit relationship found with steepness = ",
            steep$Value, " and SE = ", hs_sd, ".\n")
    if (nsim ==1) {
      hs <- steep$Value
    } else  {
      if (meanh) {
        set.seed(42)
        hs <- rep(steep$Value, nsim)
        message("Using mean steepness value: ", steep$Value)
      } else{
        set.seed(42)
        hs <- rnorm(nsim, steep$Value, hs_sd)
        message("Steepness sampled with range: ", paste(round(range(hs), 3), collapse = " - "))
      }
      
    }
    hs[hs < 0.2] <- 0.2
    hs[hs > 0.99] <- 0.99
    
  } else if(replist$SRRtype == 2) {
    SR <- "Ricker"
    OM@SRrel <- 2L
    steep <- replist$parameters[grepl("SR_Ricker", rownames(replist$parameters)), ]
    hs_sd <- ifelse(is.na(steep$Parm_StDev), 0, steep$Parm_StDev)
    message("Ricker stock-recruit relationship found with steepness = ", steep$Value, " and SE = ", hs_sd, ".\n")
    
    if (nsim ==1) {
      hs <- steep$Value
    } else  {
      if (meanh) {
        set.seed(42)
        hs <- rep(steep$Value, nsim)
        message("Using mean steepness value: ", steep$Value)
      } else{
        set.seed(42)
        hs <- rnorm(nsim, steep$Value, hs_sd)
        message("Steepness sampled with range: ", paste(round(range(hs), 3), collapse = " - "))
      }
      
    }
    hs[hs < 0.2] <- 0.2
    
  } else if(replist$SRRtype == 7) {
    SR <- "BH"
    OM@SRrel <- 1L
    
    s_frac <- replist$parameters$Value[replist$parameters$Label == "SR_surv_Sfrac"]
    Beta <- replist$parameters$Value[replist$parameters$Label == "SR_surv_Beta"]
    
    s0 <- 1/SpR0
    z0 <- -log(s0)
    z_min <- z0 * (1 - s_frac)
    
    hs <- 0.2 * exp(z0 * s_frac * (1 - 0.2 ^ Beta))
    
    message("Survival-based stock-recruit relationship was detected with steepness = ", round(hs, 2), ".")
    message("As an approximation, a Beverton-Holt relationship is used with the same steepness value.")
    
    hs <- rep(hs, nsim)
    
  } else {
    SR <- OM@SRrel <- 1L
    message("From r4ss, SRRtype = ", replist$SRRtype)
    message("Steepness value not found. By default, estimating a range of Beverton-Holt steepness by re-sampling R and SSB estimates from assessment.\n")
    
    hs <- SRopt(nsim, SSB, rec, SpR0, plot = FALSE, type = ifelse(SR == 1, "BH", "Ricker"))
    message("Range of steepness is ", paste(round(range(hs), 2), collapse = " - "))
  }
  
  OM@cpars$hs <- hs
  OM@h <- quantile(hs, c(0.025, 0.975)) %>% as.numeric()
  
  # ---- Maximum Age and M-at-Age ----
  suppressWarnings(
    m_at_age <- replist$M_at_age %>%
      tidyr::gather(., "Age", "M", 4:ncol(replist$M_at_age)) %>%
      dplyr::mutate(Age=as.numeric(Age)) %>%
      dplyr::filter(Gender %in% Gen) %>%
      dplyr::group_by(Year, Age) %>%
      dplyr::mutate(M=as.numeric(M)) %>%
      dplyr::summarise(M=mean(M), .groups='keep') # mean M over sexes
  )
  if (all(is.na( m_at_age$M[m_at_age$Age==max(m_at_age$Age)]))) {
    # M for last age is assumed same as maxage -1
    m_at_age$M[m_at_age$Age==max(m_at_age$Age)] <-  m_at_age$M[m_at_age$Age==max(m_at_age$Age)-1]
  }
  
  m_at_age$Year <- as.numeric(m_at_age$Year)
  maxage <- max(m_at_age$Age)
  n_age <- maxage + 1 # number of age classes
  
  m_at_age <- m_at_age %>% filter(Year %in% mainyrs) # age
  ageind <- m_at_age$Age[is.na(m_at_age$M)]
  m_at_age$M[m_at_age$Age == ageind] <- m_at_age$M[m_at_age$Age == ageind-1]
  
  # add last year
  if (max(m_at_age$Year) < max(mainyrs)) {
    mdf <- m_at_age %>% dplyr::filter(Year == max(mainyrs)-1)
    mdf$Year <- max(mainyrs)
    m_at_age <- rbind(m_at_age, mdf)
  }
  
  M_ageArray <- array(m_at_age$M, dim=c(n_age, OM@nyears))
  projM <- matrix(M_ageArray[,nyears], nrow=n_age, ncol=OM@proyears)
  M_ageArray <- cbind(M_ageArray, projM)
  
  M_ageArray <- replicate(OM@nsim, M_ageArray) %>% aperm(c(3,1,2))
  OM@cpars$M_ageArray <- M_ageArray
  
  OM@M <- apply(M_ageArray, 2, mean, na.rm=TRUE)
  # OM@M2 <- OM@M + 1E-6 # no longer used in DLMtool V6
  OM@maxage <- maxage
  OM@Msd <- c(0, 0)  # No time-varying M
  message("Natural mortality found.")
  
  # ---- Growth ----
  if(season_as_years) stop("Can't deal with season_as_years yet ...")
  growdat <- getGpars(replist)      # Age-specific parameters in endyr
  
  if(replist$growthvaries) {
    # stop("Time-varying growth found. Not currently handled in this function")
    message("Time-varying growth found. Not currently handled in this function")
  }
  
  # Length and weight
  if (utils::packageVersion("r4ss") < 1.38) {
    Len_age <- growdat %>% filter(Gender %in% Gen) %>%
      group_by(Age) %>%
      summarise(Length=mean(Len_Beg), .groups=='keep')
  } else {
    Len_age <- growdat %>% dplyr::filter(Gender %in% Gen) %>%
      dplyr::group_by(Age_Beg) %>%
      dplyr::summarise(Length=mean(Len_Mid), .groups="keep") # average over sexes
  }
  
  Len_age2 <- array(NA, dim = c(n_age, nsim, nyears+proyears))
  Len_age2[, , 1:nyears] <- Len_age$Length
  Len_age2[, , nyears + 1:proyears] <- Len_age2[, , nyears]
  message("Length-at-age found.")
  OM@cpars$Len_age <- aperm(Len_age2, c(2, 1, 3))
  
  GP <- replist$Growth_Parameters   # Some growth parameters (presumably in endyr)
  muLinf <- GP$Linf[1]
  cvLinf <- GP$CVmax[1]
  if(cvLinf > 1) cvLinf <- cvLinf/muLinf
  
  OM@LenCV <- rep(cvLinf, 2)
  OM@Ksd <- OM@Linfsd <- c(0, 0)
  OM@K <- OM@Linf <- OM@t0 <- c(0,0) # not used - vB pars estimated from Len_age internally
  
  # Weight at age
  ##### ALTERNATIVE #####
  # use Wt_Beg or Wt_Mid
  # # weighted weight-at-age below
  # Wt_age <- growdat %>% dplyr::filter(Gender %in% Gen) %>%
  #   group_by(Age) %>%
  #   summarise(Weight=mean(Wt_Beg))
  # Wt_age2 <- array(NA, dim = c(n_age, nsim, nyears+proyears))
  # Wt_age2[, , 1:nyears] <- Wt_age$Weight
  # Wt_age2[, , nyears + 1:proyears] <- Wt_age2[, , nyears]
  # OM@cpars$Wt_age <- aperm(Wt_age2, c(2, 1, 3)) # dims = nsim, n_age, nyears+proyears
  # message("Weight-at-age found.")
  
  # # # weight weight-at-age by N-at-age
  if (utils::packageVersion("r4ss") < 1.38) {
    Wt_age <- growdat %>% dplyr::filter(Sex %in% Gen) %>%
      dplyr::group_by(Sex, Age) %>%
      dplyr::select(Sex, Age, Wt_Mid)
  } else {
    Wt_age <- growdat %>% dplyr::filter(Sex %in% Gen) %>%
      dplyr::group_by(Sex, Age=Age_Beg) %>%
      dplyr::select(Sex, Age, Wt_Mid)
  }
  
  Wt_age <- tidyr::pivot_wider(Wt_age, names_from = Sex,
                               values_from=Wt_Mid, names_prefix = 'Wght')
  
  n_at_age <- replist$natage %>% dplyr::filter(Yr %in% mainyrs, `Beg/Mid`=='M') %>%
    dplyr::group_by(Sex, Yr) %>%
    dplyr::select(-Area, -Bio_Pattern, -BirthSeas, -Platoon, -Morph, -Seas, -Time, -`Beg/Mid`, -Era)
  firstcol <- which(colnames(n_at_age) == AgeRec)
  n_at_age <- tidyr::pivot_longer(n_at_age, cols=all_of(firstcol):ncol(n_at_age),
                                  names_to ="Age", values_to="N")
  n_at_age$Age <- as.numeric(n_at_age$Age)
  n_at_age <- tidyr::pivot_wider(n_at_age, names_from = Sex, values_from=N, names_prefix = 'N')
  
  Wt_n <- dplyr::left_join(Wt_age, n_at_age, by=c("Age"))
  Wt_n <- Wt_n %>% dplyr::group_by(Age, Yr) %>%
    dplyr::mutate(W=weighted.mean(c(Wght1, Wght2), c(N1,N2)))
  
  Wt_n <- Wt_n %>% dplyr::select(Yr, Age, W) %>%
    tidyr::pivot_wider( names_from = Age, values_from=W, names_prefix = 'Age')
  
  Wt_age2 <- array(NA, dim = c(n_age, nyears+proyears))
  Wt_age2[, 1:nyears] <- t(Wt_n[,2:ncol(Wt_n)])
  Wt_age2 <- replicate(nsim, Wt_age2)
  Wt_age2 <- aperm(Wt_age2, c(3, 1, 2))
  Wt_age2[, , nyears + 1:proyears] <- Wt_age2[, , nyears]
  OM@cpars$Wt_age <- Wt_age2 # dims = nsim, max_age, nyears+proyears
  message("Weight-at-age found.")
  
  OM@a <- replist$Growth_Parameters$WtLen1[1]
  OM@b <- replist$Growth_Parameters$WtLen2[1]
  
  # ---- Maturity ----
  if (utils::packageVersion("r4ss") < 1.38) {
    Age_Mat <- growdat %>% dplyr::filter(Gender %in% 1) %>%
      group_by(Age) %>%
      select(Age, Age_Mat) # female maturity
  } else {
    Age_Mat <- growdat %>% dplyr::filter(Gender %in% 1) %>%
      dplyr::group_by(Age=Age_Beg) %>%
      dplyr::select(Age, Age_Mat) # female maturity
  }
  
  Mat_age <- array(NA, dim = c(n_age, nsim, nyears+proyears))
  Mat_age[, , 1:nyears] <- Age_Mat$Age_Mat
  Mat_age[, , nyears + 1:proyears] <- Mat_age[, , nyears]
  OM@cpars$Mat_age <- aperm(Mat_age, c(2, 1, 3))  # dims = nsim, max_age, nyears+proyears
  message("Maturity-at-age found.")
  
  OM@L50 <- OM@L50_95 <- c(0,0) # calculated internally
  
  # ---- Depletion ----
  InitF_ind <- grepl("InitF", replist$parameters$Label)
  InitF <- replist$parameters$Value[InitF_ind]
  
  if(any(InitF > 0)) {
    initD <- SSB[1]/SSB0
    OM@cpars$initD <- rep(initD, nsim)
    message("Initial depletion: OM@cpars$initD = ", round(initD, 2))
  }
  
  OM@D <- rep(replist$current_depletion, 2)
  message("Current depletion: OM@D = ", round(replist$current_depletion, 2), "\n")
  
  # ---- Recruitment deviations ----
  year_first_rec_dev <- mainyrs[1] - maxage
  rec_ind <- match(year_first_rec_dev:(replist$endyr-AgeRec), replist$recruit$Yr)
  calcdev <- log(replist$recruit$pred_recr) - log(replist$recruit$exp_recr)
  recs <- calcdev[rec_ind]
  
  # recs <- replist$recruit$dev[rec_ind]
  recs[is.na(recs)] <- 0
  
  if(all(recs == 0)) {
    AC <- 0
  } else {
    AC <- acf(recs[recs != 0], plot = FALSE)$acf[2, 1, 1]
    if(is.na(AC)) AC <- 0
  }
  
  procsd <- replist$sigma_R_in
  procmu <- -0.5 * procsd^2  * (1 - AC)/sqrt(1 - AC^2) # adjusted log normal mean
  Perr_hist <- matrix(rep(recs, each = nsim), nrow = nsim, ncol=n_age+nyears-1) # Historical recruitment is deterministic
  Perr_proj <- matrix(rnorm(proyears * nsim, rep(procmu, each = nsim),
                            rep(procsd, each = nsim)), nrow = nsim, ncol=proyears) # Sample recruitment for projection
  
  if(AC != 0) {
    for(y in 1:ncol(Perr_proj)) { # Add autocorrelation to projection recruitment
      if(y == 1) {
        Perr_proj[, y] <- AC * Perr_hist[, ncol(Perr_hist)] + Perr_proj[, y] * sqrt(1 - AC^2)
      } else {
        Perr_proj[, y] <- AC * Perr_proj[, y-1] + Perr_proj[, y] * sqrt(1 - AC^2)
      }
    }
  }
  
  Perr_y <- cbind(Perr_hist, Perr_proj)
  
  OM@cpars$Perr_y <- exp(Perr_y)
  OM@Perr <- rep(procsd, 2) # uniform range is a point estimate from assessment MLE
  OM@AC <- rep(AC, 2)
  message("Recruitment deviates found and sampled.")
  
  # CAL Bins #
  if (utils::packageVersion("r4ss") < 1.38) {
    OM@cpars$CAL_bins <- replist$lendbase$Bin %>% unique() %>% sort()
    Binwidth <- OM@cpars$CAL_bins[2] - OM@cpars$CAL_bins[1]
    OM@cpars$CAL_binsmid <- seq(OM@cpars$CAL_bins[1]+0.5*Binwidth,
                                by=Binwidth,
                                length.out=length(OM@cpars$CAL_bins)-1)
    
  } else {
    # looks like length bins have moved in this version
    nms <- colnames(replist$natlen)
    ind <- which(nms == 'Era')
    OM@cpars$CAL_bins <- as.numeric(nms[(ind+1):length(nms)])
    Binwidth <- OM@cpars$CAL_bins[2] - OM@cpars$CAL_bins[1]
    OM@cpars$CAL_binsmid <- seq(OM@cpars$CAL_bins[1]+0.5*Binwidth,
                                by=Binwidth,
                                length.out=length(OM@cpars$CAL_bins)-1)
    
  }
  
  # ---- Movement modelling ----
  OM@Frac_area_1 <- OM@Size_area_1 <- OM@Prob_staying <- rep(0.5, 2)
  if(import_mov && nrow(replist$movement) > 0) {
    movement <- replist$movement[replist$movement$Seas == 1 & replist$movement$Gpattern == 1, ]
    if(nrow(movement) == 0) movement <- replist$movement[replist$movement$Seas == 1 & replist$movement$GP == 1, ]
    
    nareas <- length(unique(movement$Source_area))
    message(nareas, " area model found. Parameterizing movement matrix.")
    
    full_movement <- movement[, grepl("age", names(movement)) & names(movement) != "minage" & names(movement) != "maxage"]
    
    nages <- ncol(full_movement)
    mov <- array(NA, c(nsim, nages, nareas, nareas))
    
    for(i in 1:nrow(full_movement)) {
      from <- movement$Source_area[i]
      to <- movement$Dest_area[i]
      
      for(j in 1:ncol(full_movement)) mov[1:nsim, j, from, to] <- full_movement[i, j]
    }
    mov[is.na(mov)] <- 0
    
    if(season_as_years) mov <- mov[, seas1_aind, , , drop = FALSE]
    
    OM@cpars$mov <- mov
  }
  
  # ---- Fleet Parameters ----
  # ---- Vulnerability ----
  if(!is.null(replist$Z_at_age $Sex)) {
    Z_at_age <- replist$Z_at_age %>%
      dplyr::filter(Yr %in% mainyrs, Sex %in% Gen) %>%
      tidyr::gather(., "Age", "Z", 4:ncol( replist$Z_at_age)) %>%
      dplyr::mutate(Age=as.numeric(Age)) %>%
      dplyr::group_by(Year=Yr, Age) %>%
      dplyr::summarise(Mort=mean(Z), .groups='keep')
  } else {
    Z_at_age <- replist$Z_at_age %>%
      dplyr::filter(Year %in% mainyrs, Gender %in% Gen) %>%
      tidyr::gather(., "Age", "Z", 4:ncol( replist$Z_at_age)) %>%
      dplyr::mutate(Age=as.numeric(Age)) %>%
      dplyr::group_by(Year, Age) %>%
      dplyr::summarise(Mort=mean(Z), .groups='keep')
  }
  
  
  if(max(Z_at_age$Year) != max(mainyrs)) {
    df <- Z_at_age %>% dplyr::filter(Year == max(Z_at_age$Year))
    df$Year <- max(mainyrs)
    Z_at_age <- rbind(Z_at_age, df)
  }
  
  M_at_age <- m_at_age %>% dplyr::filter(Year <= max(mainyrs)) # already calculated above
  M_at_age$Mort <- M_at_age$M
  
  if(max(M_at_age$Year) != max(mainyrs)) {
    df <- M_at_age %>% dplyr::filter(Year == max(M_at_age$Year))
    df$Year <- max(mainyrs)
    M_at_age <- rbind(M_at_age, df)
  }
  
  F_at_age <- Z_at_age
  M_at_age$Mort[M_at_age$Age==maxage] <- M_at_age$Mort[M_at_age$Age==maxage-1]
  Z_at_age$Mort[Z_at_age$Age==maxage] <- Z_at_age$Mort[Z_at_age$Age==maxage-1]
  F_at_age$Mort <- Z_at_age$Mort - M_at_age$Mort
  F_at_age$Mort[F_at_age$Mort < 1e-8] <- 1e-8
  
  V <- array(NA, dim = c(n_age, nyears + proyears, nsim))
  V[, 1:nyears, ] <- array(F_at_age$Mort, dim = c(n_age, nyears, nsim))
  V[, nyears:(nyears+proyears), ] <- V[, nyears, ]
  V <- aperm(V, c(3, 1, 2))
  
  Find <- apply(V[,,1:nyears], c(1, 3), max, na.rm = TRUE) # get apical F
  
  # for(i in 1:nsim) {
  #   for(j in 1:(nyears)) {
  #     V[i, , j] <- V[i, , j]/Find[i, j]
  #   }
  # }
  # V[,,(nyears+1):(nyears+proyears)] <- V[,,nyears]
  #
  # OM@cpars$V <- V
  # message("Selectivity found.")
  
  #### ALTERNATIVE #####
  # calculate selectivity-at-length and retention-at-length
  Length_Select <- replist$sizeselex %>% dplyr::filter(Yr %in% mainyrs)
  LengthSelect <- Length_Select %>% tidyr::pivot_longer(cols=6:ncol(Length_Select),
                                                        names_to="Mid",
                                                        values_to="Sel")
  
  # ---- Calculate overall selectivity & retention curves for each year ---
  nCALbins <- length(OM@cpars$CAL_binsmid)
  SLarray <- retL <- array(NA, dim=c(nCALbins, OM@nyears+OM@proyears))
  
  # Loop over years - update selectivity values for each year
  tempdf <- LengthSelect %>% filter(Yr == mainyrs[1])
  templist <- replicate(nyears, tempdf, simplify = FALSE)
  chng_yrs <- LengthSelect$Yr %>% unique() %>% sort()
  chng_ind <- match(chng_yrs, mainyrs)
  for (ii in seq_along(mainyrs)) {
    templist[[ii]]$Yr <- mainyrs[ii]
    if (ii %in% chng_ind) {
      tempval <- LengthSelect %>% filter(Yr == mainyrs[ii])
      flts <- tempval$Fleet %>% unique() %>% sort()
      for (fl in flts) {
        tempval2 <- LengthSelect %>% dplyr::filter(Yr==mainyrs[ii], Fleet==fl)
        templist[[ii]]$Sel[templist[[ii]]$Fleet == fl] <- tempval2$Sel
      }
    } else {
      templist[[ii]]$Sel <- templist[[ii-1]]$Sel
    }
  }
  tempdf2 <- do.call(rbind,templist)
  
  # selectivity and retention for each fleet and year
  Length_Select_Overall <- tempdf2 %>% dplyr::group_by(Yr, Mid, Factor)
  Length_Select_Overall$Mid <- as.numeric(Length_Select_Overall$Mid)
  
  
  # ---- Calculate exploitation rate by fleet for each year ----
  Expl <- replist$exploitation %>% dplyr::filter(Yr%in%mainyrs)
  Expl <- Expl[,c(1,4:ncol(Expl))]
  colnames(Expl) <- c("Yr", 1:11)
  Expl <- tidyr::pivot_longer(Expl, 2:ncol(Expl), 'Fleet', 'Expl', values_to = 'Exploit')
  Expl$Fleet <- as.numeric(Expl$Fleet)
  
  Length_Select_Overall <- Length_Select_Overall %>% dplyr::filter(Fleet %in% unique(Expl$Fleet))
  Length_Select_Overall <- dplyr::left_join(Length_Select_Overall, Expl, by=c("Yr", "Fleet"))
  
  # ---- Selectivity ----
  Select <- Length_Select_Overall %>%
    dplyr::summarise(Value=weighted.mean(Sel, w=Exploit), .groups='keep') %>%  # weight by exploitation by fleet
    dplyr::filter(Factor=="Lsel", Mid %in% OM@cpars$CAL_binsmid) %>%
    tidyr::pivot_wider(names_from = Mid, values_from = Value)
  
  SLarray[,1:OM@nyears] <- t(Select[,3:ncol(Select)])
  SLarray[,(OM@nyears+1):ncol(SLarray)] <- SLarray[,OM@nyears]
  SLarray <- replicate(OM@nsim, SLarray)
  SLarray <- aperm(SLarray, c(3,1,2))
  
  # yr <- 1951
  # yrind <- match(yr, mainyrs)
  # Bins <- OM@cpars$CAL_binsmid
  # plot(Bins, SLarray[1, , yrind], type="b", ylim=c(0,1))
  #
  # chk <- Length_Select_Overall %>% dplyr::filter(Yr == yr, Factor=="Lsel") %>%
  #   dplyr::group_by(Mid) %>%
  #   dplyr::summarise(Select=weighted.mean(Sel, Exploit))
  #
  # lines(chk$Mid, chk$Select, col='blue')
  
  # ---- Retention ----
  Retain <- Length_Select_Overall %>%
    dplyr::summarise(Value=weighted.mean(Sel, w=Exploit), .groups='keep') %>%  # weight by exploitation by fleet
    dplyr::filter(Factor=="Keep", Mid %in% OM@cpars$CAL_binsmid) %>%
    tidyr::pivot_wider(names_from = Mid, values_from = Value)
  
  retL[,1:OM@nyears] <- t(Retain[,3:ncol(Retain)])
  retL[,(OM@nyears+1):ncol(retL)] <- retL[,OM@nyears]
  retL <- replicate(OM@nsim, retL)
  retL <- aperm(retL, c(3,1,2))
  
  
  # ---- Discard Mortality ----
  # Update selectivity curve with discard mortality
  # ie fish that don't suffer discard mort. don't show up in the select curve
  DeadDiscard <- Length_Select_Overall %>%
    dplyr::summarise(Value=weighted.mean(Sel, w=Exploit), .groups='keep') %>%  # weight by exploitation by fleet
    dplyr::filter(Factor=="Dead", Mid %in% OM@cpars$CAL_binsmid) %>%
    tidyr::pivot_wider(names_from = Mid, values_from = Value)
  
  DeadArray <- array(NA, dim=c(nCALbins, OM@nyears+OM@proyears))
  
  DeadArray[,1:OM@nyears] <- t(DeadDiscard[,3:ncol(Select)])
  DeadArray[,(OM@nyears+1):ncol(DeadArray)] <- DeadArray[,OM@nyears]
  DeadArray <- replicate(OM@nsim, DeadArray)
  DeadArray <- aperm(DeadArray, c(3,1,2))
  
  SLarray <- DeadArray
  
  OM@cpars$SLarray <- SLarray
  OM@cpars$retL <- retL
  OM@cpars$V <- NULL
  
  OM@DR <- c(0,0) # no general discard ratio
  OM@L5 <- OM@LFS <- OM@Vmaxlen <- c(0,0) # calculated internally
  OM@isRel <- "FALSE" # these are real lengths not relative to length at 50% maturity
  
  OM@cpars$Find <- Find[,1:nyears] # is only historical years
  message("Historical F found.")
  
  OM@Spat_targ <- rep(1, 2)
  Fpos <- Find[, 1:(nyears-1)]
  Fpos <- Fpos[, apply(Fpos,2,sum) > 0]
  Fpos[Fpos == 0] <- 1e-5
  ind1 <- 1:(ncol(Fpos)-1)
  ind2 <- 2:ncol(Fpos)
  Esd <- apply((Fpos[, ind1] - Fpos[, ind2])/Fpos[,ind2], 1, sd)
  OM@Esd <- quantile(Esd, c(0.025, 0.975))
  if(season_as_years) OM@EffYears <- 1:nyears else OM@EffYears <- mainyrs
  OM@EffLower <- OM@EffUpper <- Find[1, 1:nyears]
  OM@qinc <- c(0, 0)
  OM@qcv <- c(0, 0)
  OM@CurrentYr <- ifelse(season_as_years, nyears, replist$endyr)
  OM@MPA <- FALSE
  
  
  # ---- Observation Parameters ----
  
  # Catch Error
  CSD <- replist$catch_error
  if(all(is.na(CSD)) && packageVersion("r4ss") == 1.35) CSD <- replist$catch_se
  if(!all(is.na(CSD))) {
    CSD <- CSD[!is.na(CSD)]
    OM@Cobs <- range(sqrt(exp(CSD[CSD > 0]^2) - 1), na.rm = TRUE)
    message("\nRange of error in catch (OM@Cobs) based on range of catch standard deviations: ",
            paste(CSD, collapse = " "))
  }
  
  # Index Error
  cpue <- data.frame(Fleet = replist$cpue$Fleet, SE = replist$cpue$SE)
  fleet_means <- aggregate(cpue, list(cpue$Fleet), mean, na.rm = TRUE)
  OM@Iobs <- range(sqrt(exp(fleet_means$SE^2) - 1), na.rm = TRUE)
  message("Range of error in index (OM@Iobs) based on range of index standard deviation means for each fleet or survey: ",
          paste(round(fleet_means$SE, 2), collapse = " "))
  
  #get_beta<-function(beta,x,y) sum((y - x^beta)^2, na.rm = TRUE)
  #OM@beta<-rep(optimize(getbeta,x=replist$cpue$Obs,y=replist$cpue$Exp,interval=c(0.1, 2))$minimum,2)
  
  message("Import successful. Use plot OM function to view imported operating model parameters.")
  OM@interval <- interval
  OM
}


# #' A function that samples multivariate normal (logspace) variables
# #'
# #' @param xmu The mean (normal space) of the first (x) variable
# #' @param ymu The mean (normal space) of the second (y) variable
# #' @param xcv The coefficient of variation (normal space, log normal sd) of the x variable
# #' @param nsim The number of random draws
# #' @param cor The off-diagonal (symmetrical) correlation among x and y
# #' @param ploty Whether a plot of the sampled variables should be produced
# #' @author T. Carruthers
# #' @export negcorlogspace
#' @importFrom mvtnorm rmvnorm
negcorlogspace<-function(xmu,ymu,xcv=0.1,nsim,cor=-0.9,ploty=FALSE){
  
  varcov=matrix(c(1,cor,cor,1),nrow=2)
  out<-mvtnorm::rmvnorm(nsim,c(0,0),sigma=varcov)
  out<-out/rep(apply(out,2,sd)/xcv,each=nsim)
  out<-exp(out)
  out<-out/rep(apply(out,2,mean),each=nsim)
  out[,1]<-out[,1]*xmu
  out[,2]<-out[,2]*ymu
  if(ploty)plot(out[,1],out[,2])
  out
  
}

ilogit <- function(x) 1/(1 + exp(-x))

# #' Simplified a multi-area transition matrix into the best 2 x 2 representation
# #'
# #' @description A Function that takes a larger movement matrix, identifies the most parsimonious representation of 2 non-mixed areas and returns the final unfished movement matrix
# #' @param movtab a table of estimated movements
# #' @author T. Carruthers
# #' @export
# movdistil<-function(movtab){
#
#   nareas<-max(movtab$Source_area,movtab$Dest_area)
#   mov<-array(0,c(nareas,nareas))
#   mov[cbind(movtab$Source_area,movtab$Dest_area)]<-movtab[,ncol(movtab)]
#
#   vec<-rep(1/nareas,nareas)
#   for(i in 1:100)vec<-vec%*%mov
#   endmov<-array(vec,c(nareas,nareas))*mov
#
#   listy<-new('list')
#   for(i in 1:nareas)listy[[i]]<-c(1,2)
#
#   combins<-expand.grid(listy)
#   combins<-combins[!apply(combins,1,sum)%in%c(nareas*1,nareas*2),]
#   nc<-nrow(combins)/2
#   combins<-combins[(nc+1):nrow(combins),]
#
#   base<-cbind(expand.grid(1:nareas,1:nareas),as.vector(endmov))
#
#   emt<-NULL
#   out<-rep(NA,nc)
#
#   for(i in 1:nc){
#
#     vec<-combins[i,]
#     vec<-c(-1,1)[as.numeric(vec)]
#     out[i]<-sum((vec-(vec%*%mov))^2)
#
#   }
#
#   best<-as.numeric(combins[which.min(out),])
#
#   aggdat<-cbind(expand.grid(best,best),as.vector(endmov))
#   agg<-aggregate(aggdat[,3],by=list(aggdat[,1],aggdat[,2]),sum)
#   newmov<-array(NA,c(2,2))
#   newmov[as.matrix(agg[,1:2])]<-agg[,3]
#   newmov/apply(newmov,1,sum)
#
# }

# #' Predict recruitment and return fit to S-R observations
# #'
# #' @description Internal function to \link{optSR}
# #' @param pars an initial guess at model parameters steepness and R0
# #' @param SSB 'observations' of spawning biomass
# #' @param rec 'observations' (model predictions) of recruitment
# #' @param SSBpR spawning stock biomass per recruit at unfished conditions
# #' @param mode should fit (= 1) or recruitment deviations (not 1) be returned
# #' @param plot should a plot of the model fit be produced?#'
# #' @param type what type of stock recruitment curve is being fitted ("BH" = Beverton-Holt or "Ricker")
# #' @author T. Carruthers
# #' @export
getSR <- function(pars, SSB, rec, SSBpR, mode = 1, plot = FALSE, type = c("BH", "Ricker")){
  R0 <- exp(pars[2])
  if(type == "BH") {
    h <- 0.2 + 0.8 * ilogit(pars[1])
    recpred<-((0.8*R0*h*SSB)/(0.2*SSBpR*R0*(1-h)+(h-0.2)*SSB))
  }
  if(type == "Ricker") {
    h <- 0.2 + exp(pars[1])
    recpred <- SSB * (1/SSBpR) * (5*h)^(1.25*(1 - SSB/(R0*SSBpR)))
  }
  
  if(plot){
    ord <- order(SSB)
    plot(SSB[ord], rec[ord], ylim=c(0, max(rec, R0)), xlim=c(0, max(SSB, R0*SSBpR)), xlab="", ylab="")
    SSB2 <- seq(0, R0*SSBpR, length.out=500)
    if(type == "BH") recpred2 <- ((0.8*R0*h*SSB2)/(0.2*SSBpR*R0*(1-h)+(h-0.2)*SSB2))
    if(type == "Ricker") recpred2 <- SSB2 * (1/SSBpR) * (5*h)^(1.25*(1 - SSB2/(R0*SSBpR)))
    lines(SSB2, recpred2, col='blue')
    abline(v=c(0.2*R0*SSBpR, R0*SSBpR), lty=2, col='red')
    abline(h=c(R0, R0*h), lty=2, col='red')
    legend('topright', legend=c(paste0("h = ", round(h,3)), paste0("ln(R0) = ", round(log(R0),3))), bty='n')
  }
  
  if(mode==1){
    #return(sum(((recpred-rec)/10000)^2))
    sigmaR <- sqrt(sum((log(rec/recpred))^2)/length(recpred))
    return(-sum(dnorm(log(rec)-log(recpred),0,sigmaR,log=T)))
    #-dnorm(pars[1],0,6,log=T)) # add a vague prior on h = 0.6
    #return(-sum(dnorm(recpred,rec,rec*0.5,log=T)))
  }else{
    return(rec-recpred)
  }
}

# #' Wrapper for estimating stock recruitment parameters from resampled stock-recruitment data
# #'
# #' @param x position to accommodate lapply-type functions
# #' @param SSB 'observations' of spawning biomass
# #' @param rec 'observations' (model predictions) of recruitment
# #' @param SSBpR spawning stock biomass per recruit at unfished conditions
# #' @param pars an initial guess at model parameters steepness and R0
# #' @param frac the fraction of observations for resampling
# #' @param plot should a plot of model fit be produced?
# #' @param type what type of stock recruitment curve is being fitted ("BH" = Beverton-Holt or "Ricker")
# #' @return Estimated value of steepness.
# #' @author T. Carruthers
# #' @export
optSR<-function(x, SSB, rec, SSBpR, pars, frac = 0.5, plot = FALSE, type = c("BH", "Ricker")) {
  type <- match.arg(type)
  samp <- sample(1:length(SSB), size = ceiling(length(SSB) * frac), replace = FALSE)
  opt <- optim(pars, getSR, method = "BFGS", #lower = c(-6, pars[2]/50), upper = c(6, pars[2] * 50),
               SSB = SSB[samp], rec = rec[samp], SSBpR = SSBpR, mode = 1, plot = FALSE, type = type)
  if(plot) getSR(opt$par, SSB, rec, SSBpR, mode = 2, plot = plot, type = type)
  if(type == "BH") h <- 0.2 + 0.8 * ilogit(opt$par[1])
  if(type == "Ricker") h <- 0.2 + exp(opt$par[1])
  return(h)
}

# #' Function that returns a stochastic estimate of steepness given observed stock recruitment data
# #'
# #' @param nsim number of samples of steepness to generate
# #' @param SSB 'observations' of spawning biomass
# #' @param rec 'observations' (model predictions) of recruitment
# #' @param SSBpR spawning stock biomass per recruit at unfished conditions
# #' @param plot should plots of model fit be produced?
# #' @param type what type of stock recruitment curve is being fitted ("BH" = Beverton-Holt or "Ricker")
# #' @return Vector of length nsim with steepness values.
# #' @author T. Carruthers
# #' @export
SRopt <- function(nsim, SSB, rec, SSBpR, plot = FALSE, type = c("BH", "Ricker")) {
  type <- match.arg(type)
  R0temp <- rec[1] # have a guess at R0 for initializing nlm
  pars <- c(0, log(R0temp))
  #SSBpR=SSB[1]/rec[1]
  vapply(1:nsim, optSR, numeric(1), SSB = SSB, rec = rec, SSBpR = SSBpR, pars = pars, frac = 0.8,
         plot = plot, type = type)
}


# #' Extracts growth parameters from a SS3 r4ss replist
# #'
# #' @param replist the list output of the r4ss SS_output function (a list of assessment inputs / outputs)
# #' @param seas The reference season for the growth (not actually sure what this does yet)
# #' @author T. Carruthers
# #' @export getGpars
getGpars <- function(replist, seas = 1) { # This is a rip-off of SSPlotBiology
  
  if(packageVersion("r4ss") == 1.24) {
    res <- getGpars_r4ss_124(replist, seas)
  } else res <- getGpars_r4ss_134(replist, seas)
  if(nrow(res) == 0) warning("No growth parameters were retrieved from r4ss output.")
  return(res)
}

getGpars_r4ss_124 <- function(replist, seas = 1) {
  
  nseasons <- replist$nseasons
  growdat <- replist$endgrowth[replist$endgrowth$Seas == seas, ]
  growdat$CV_Beg <- growdat$SD_Beg/growdat$Len_Beg
  growthCVtype <- replist$growthCVtype
  biology <- replist$biology
  startyr <- replist$startyr
  FecType <- replist$FecType
  FecPar1name <- replist$FecPar1name
  FecPar2name <- replist$FecPar2name
  FecPar1 <- replist$FecPar1
  FecPar2 <- replist$FecPar2
  parameters <- replist$parameters
  nsexes <- replist$nsexes
  mainmorphs <- replist$mainmorphs
  accuage <- replist$accuage
  startyr <- replist$startyr
  endyr <- replist$endyr
  growthvaries <- replist$growthvaries
  growthseries <- replist$growthseries
  ageselex <- replist$ageselex
  MGparmAdj <- replist$MGparmAdj
  wtatage <- replist$wtatage
  Growth_Parameters <- replist$Growth_Parameters
  Grow_std <- replist$derived_quants[grep("Grow_std_", replist$derived_quants$LABEL), ]
  if (nrow(Grow_std) == 0) {
    Grow_std <- NULL
  }  else {
    Grow_std$pattern <- NA
    Grow_std$sex_char <- NA
    Grow_std$sex <- NA
    Grow_std$age <- NA
    for (irow in 1:nrow(Grow_std)) {
      tmp <- strsplit(Grow_std$LABEL[irow], split = "_")[[1]]
      Grow_std$pattern[irow] <- as.numeric(tmp[3])
      Grow_std$sex_char[irow] <- tmp[4]
      Grow_std$age[irow] <- as.numeric(tmp[6])
    }
    Grow_std$sex[Grow_std$sex_char == "Fem"] <- 1
    Grow_std$sex[Grow_std$sex_char == "Mal"] <- 2
  }
  if (!is.null(replist$wtatage_switch)) {
    wtatage_switch <- replist$wtatage_switch
  } else{ stop("SSplotBiology function doesn't match SS_output function. Update one or both functions.")
  }
  if (wtatage_switch)
    cat("Note: this model uses the empirical weight-at-age input.\n",
        "     Therefore many of the parametric biology quantities which are plotted\n",
        "     are not used in the model.\n")
  if (!seas %in% 1:nseasons)
    stop("'seas' input should be within 1:nseasons")
  
  if (length(mainmorphs) > nsexes) {
    cat("!Error with morph indexing in SSplotBiology function.\n",
        " Code is not set up to handle multiple growth patterns or birth seasons.\n")
  }
  #if (FecType == 1) {
  #  fec_ylab <- "Eggs per kg"
  #  FecX <- biology$Wt_len_F
  #  FecY <- FecPar1 + FecPar2 * FecX
  #}
  
  growdatF <- growdat[growdat$Gender == 1 & growdat$Morph ==
                        mainmorphs[1], ]
  growdatF$Sd_Size <- growdatF$SD_Beg
  
  if (growthCVtype == "logSD=f(A)") {
    growdatF$high <- qlnorm(0.975, meanlog = log(growdatF$Len_Beg),
                            sdlog = growdatF$Sd_Size)
    growdatF$low <- qlnorm(0.025, meanlog = log(growdatF$Len_Beg),
                           sdlog = growdatF$Sd_Size)
  }  else {
    growdatF$high <- qnorm(0.975, mean = growdatF$Len_Beg,
                           sd = growdatF$Sd_Size)
    growdatF$low <- qnorm(0.025, mean = growdatF$Len_Beg,
                          sd = growdatF$Sd_Size)
    growdatF$Gender <- 1
  }
  if (nsexes > 1) {
    growdatM <- growdat[growdat$Gender == 2 & growdat$Morph ==
                          mainmorphs[2], ]
    xm <- growdatM$Age_Beg
    growdatM$Sd_Size <- growdatM$SD_Beg
    if (growthCVtype == "logSD=f(A)") {
      growdatM$high <- qlnorm(0.975, meanlog = log(growdatM$Len_Beg),
                              sdlog = growdatM$Sd_Size)
      growdatM$low <- qlnorm(0.025, meanlog = log(growdatM$Len_Beg),
                             sdlog = growdatM$Sd_Size)
    }    else {
      growdatM$high <- qnorm(0.975, mean = growdatM$Len_Beg,
                             sd = growdatM$Sd_Size)
      growdatM$low <- qnorm(0.025, mean = growdatM$Len_Beg,
                            sd = growdatM$Sd_Size)
    }
    growdatM$Gender <- 2
  }
  
  rbind(growdatF, growdatM)
  
}

getGpars_r4ss_134 <- function(replist, seas = 1) {
  nseasons <- replist$nseasons
  growdat <- replist$endgrowth[replist$endgrowth$Seas == seas, ]
  growdat$CV_Beg <- growdat$SD_Beg/growdat$Len_Beg
  growthCVtype <- replist$growthCVtype
  biology <- replist$biology
  startyr <- replist$startyr
  FecType <- replist$FecType
  FecPar1name <- replist$FecPar1name
  FecPar2name <- replist$FecPar2name
  FecPar1 <- replist$FecPar1
  FecPar2 <- replist$FecPar2
  parameters <- replist$parameters
  nsexes <- replist$nsexes
  accuage <- replist$accuage
  startyr <- replist$startyr
  endyr <- replist$endyr
  growthvaries <- replist$growthvaries
  growthseries <- replist$growthseries
  ageselex <- replist$ageselex
  MGparmAdj <- replist$MGparmAdj
  wtatage <- replist$wtatage
  if ("comment" %in% names(wtatage)) {
    wtatage <- wtatage[, -grep("comment", names(wtatage))]
  }
  M_at_age <- replist$M_at_age
  Growth_Parameters <- replist$Growth_Parameters
  #if (is.null(morphs)) {
  morphs <- replist$mainmorphs
  #}
  Grow_std <- replist$derived_quants[grep("Grow_std_", replist$derived_quants$Label), ]
  if (nrow(Grow_std) == 0) {
    Grow_std <- NULL
  } else {
    Grow_std$pattern <- NA
    Grow_std$sex_char <- NA
    Grow_std$sex <- NA
    Grow_std$age <- NA
    for (irow in 1:nrow(Grow_std)) {
      tmp <- strsplit(Grow_std$Label[irow], split = "_")[[1]]
      Grow_std$pattern[irow] <- as.numeric(tmp[3])
      Grow_std$sex_char[irow] <- tmp[4]
      Grow_std$age[irow] <- as.numeric(tmp[6])
    }
    Grow_std$sex[Grow_std$sex_char == "Fem"] <- 1
    Grow_std$sex[Grow_std$sex_char == "Mal"] <- 2
  }
  if (!is.null(replist$wtatage_switch)) {
    wtatage_switch <- replist$wtatage_switch
  } else {
    stop("SSplotBiology function doesn't match SS_output function.",
         "Update one or both functions.")
  }
  #if (wtatage_switch) {
  #  cat("Note: this model uses the empirical weight-at-age input.\n",
  #      "      Plots of many quantities related to growth are skipped.\n")
  #}
  if (!seas %in% 1:nseasons)
    stop("'seas' input should be within 1:nseasons")
  #if (nseasons > 1) {
  #  labels[6] <- gsub("beginning of the year", paste("beginning of season",
  #                                                   seas), labels[6])
  #}
  
  if (length(morphs) > nsexes) {
    cat("!Error with morph indexing in SSplotBiology function.\n",
        " Code is not set up to handle multiple growth patterns or birth seasons.\n")
  }
  #if (FecType == 1) {
  #  fec_ylab <- "Eggs per kg"
  #  fec_xlab <- labels[8]
  #  FecX <- biology$Wt_len_F
  #  FecY <- FecPar1 + FecPar2 * FecX
  #}
  #if (labels[11] != "Default fecundity label")
  #  fec_ylab <- labels[11]
  growdatF <- growdat[growdat$Sex == 1 & growdat$Morph == morphs[1], ]
  growdatF$Sd_Size <- growdatF$SD_Beg
  growdatF$Gender <- 1
  if (growthCVtype == "logSD=f(A)") {
    growdatF$high <- qlnorm(0.975, meanlog = log(growdatF$Len_Beg),
                            sdlog = growdatF$Sd_Size)
    growdatF$low <- qlnorm(0.025, meanlog = log(growdatF$Len_Beg),
                           sdlog = growdatF$Sd_Size)
  } else {
    growdatF$high <- qnorm(0.975, mean = growdatF$Len_Beg,
                           sd = growdatF$Sd_Size)
    growdatF$low <- qnorm(0.025, mean = growdatF$Len_Beg,
                          sd = growdatF$Sd_Size)
  }
  if (nsexes > 1) {
    growdatM <- growdat[growdat$Sex == 2 & growdat$Morph == morphs[2], ]
    growdatM$Gender <- 2
    xm <- growdatM$Age_Beg
    growdatM$Sd_Size <- growdatM$SD_Beg
    if (growthCVtype == "logSD=f(A)") {
      growdatM$high <- qlnorm(0.975, meanlog = log(growdatM$Len_Beg),
                              sdlog = growdatM$Sd_Size)
      growdatM$low <- qlnorm(0.025, meanlog = log(growdatM$Len_Beg),
                             sdlog = growdatM$Sd_Size)
    } else {
      growdatM$high <- qnorm(0.975, mean = growdatM$Len_Beg,
                             sd = growdatM$Sd_Size)
      growdatM$low <- qnorm(0.025, mean = growdatM$Len_Beg,
                            sd = growdatM$Sd_Size)
    }
    
  }
  
  rbind(growdatF, growdatM)
  
}



someplot<-function (replist, yrs = "all", Ftgt = NA, ylab = "Summary Fishing Mortality",
                    plot = TRUE, print = FALSE, plotdir = "default", verbose = TRUE,
                    uncertainty = TRUE, pwidth = 6.5, pheight = 5, punits = "in",
                    res = 300, ptsize = 10)
{
  pngfun <- function(file, caption = NA) {
    png(filename = file, width = pwidth, height = pheight,
        units = punits, res = res, pointsize = ptsize)
    plotinfo <- rbind(plotinfo, data.frame(file = file, caption = caption))
    return(plotinfo)
  }
  plotinfo <- NULL
  if (plotdir == "default")
    plotdir <- replist$inputs$dir
  if (yrs[1] == "all") {
    yrs <- replist$startyr:replist$endyr
  }
  Ftot <- replist$derived_quants[match(paste("F_", yrs, sep = ""),
                                       replist$derived_quants$LABEL), ]
  if (all(is.na(Ftot$Value))) {
    warning("Skipping SSplotSummaryF because no real values found in DERIVED_QUANTITIES\n",
            "    Values with labels like F_2012 may not be real.\n")
    return()
  }
  Fmax <- max(c(Ftot$Value, Ftgt + 0.01), na.rm = TRUE)
  if (uncertainty) {
    uppFtot <- Ftot$Value + 1.96 * Ftot$StdDev
    lowFtot <- Ftot$Value - 1.96 * Ftot$StdDev
    Fmax <- max(c(uppFtot, Ftgt + 0.01), na.rm = TRUE)
  }
  plotfun <- function() {
    plot(0, type = "n", , xlab = "Year", ylab = ylab, xlim = range(yrs),
         ylim = c(0, Fmax), cex.lab = 1, cex.axis = 1, cex = 0.7)
    abline(h = 0, col = "grey")
    if (uncertainty)
      segments(as.numeric(substring(Ftot$LABEL, 3, 6)),
               uppFtot, as.numeric(substring(Ftot$LABEL, 3,
                                             6)), lowFtot, col = gray(0.5))
    points(as.numeric(substring(Ftot$LABEL, 3, 6)), Ftot$Value,
           pch = 16, type = "p")
    abline(h = Ftgt, col = "red")
  }
  if (plot)
    plotfun()
  if (print) {
    file <- file.path(plotdir, "ts_summaryF.png")
    caption <- "Summary F (definition of F depends on setting in starter.ss)"
    plotinfo <- pngfun(file = file, caption = caption)
    plotfun()
    dev.off()
    if (!is.null(plotinfo))
      plotinfo$category <- "Timeseries"
  }
  if (verbose)
    cat("Plotting Summary F\n")
  return(invisible(plotinfo))
}


